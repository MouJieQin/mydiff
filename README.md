# mydiff

[myers-diff-paper](https://github.com/MouJieQin/mydiff/wiki/diff2.pdf)

[myers-diff](https://github.com/MouJieQin/mydiff/wiki/myers-diff.pdf)

# 一个$O(ND)$的差分算法及其变体

#### 作者：	EUGENE W. MYERS

## 摘要
　　求两个序列$A$、$B$的最长公共子序列，和把$A$转换成$B$的最短编辑脚本一直被认为是双重问题。在本文中，它们被证明等价于在编辑图中找到最长或最短的路径。通过透视图，一个简单的$O(ND)$的时间和空间算法被开发出来，其中$N$是$A$、$B$长度之和，$D$是最小编辑脚本的长度。当两个序列差异较小(序列相似)时，该算法性能很好，因此在典型应用中具有较快的速度。在基本随机模型下，该算法显示出$O(N+D^2)$的期待时间性能。一种改进算法只要求$O(N)$的空间，使用后缀树产生一个$O(NlgN+D^2)$时间的变体。

#### 关键词 

　　最长公共子序列 最短编辑脚本 编辑图 文件比对

## 1.导言

　　确定两个符号序列之间的差异问题已经被广泛研究[1,8,11,13,16,19,20] 。该问题的算法有许多应用，包括拼写更正系统，文件比对工具，和遗传进化研究[4,5,17,18]。形式化的问题表述为：寻找最长公共子序列，或者等价地，找到将一个序列转变为另一个的最小删除和插入符号的脚本。最早的算法之一是由Wagner & Fischer [20] 提出的花费$O(N^2)$的时间和空间，解决他们称为 string-to-string correction (字符串到字符串校正) 的泛化问题。Hirschberg [7]随后发表了只使用线性空间找到最长公共子序列的改进算法。已被证明，算法在任意字符表上，使用”equal—unequal“ (相等-不等)比较，以它们的输入大小作为特征值，$Ω(N^2)$时间的花费是必须的[1]。一个称为"Four Russians"的方法在任意和限定字符集上分别促成了稍好的$O(N^2lglgN/lgN)$ 和 $O(N^2/lgN)$ 时间算法[13]。使用其它比较形式的更快算法仍然存在余地。实际上，使用"‘less than—equal—greater than" (小于-等于-大于)的比较方法，已知的最低时间边界为$Ω(NlgN)$ [9]。

　　最近的工作在任意字符集的$O(N^2)$时间的基础算法上对其它敏感参数做了改进。设输出参数$L$为最长公共子序列的长度，并将对偶参数$D=2(N-L)$设为最短编辑脚本的长度。(在整个导言中假设两个字符串都有相同的长度$N$。) Hirschberg [8] 提出了$O(NL + NlgN)$ 和 $O(DLlgN)$时间两个最佳输出-敏感算法，Hunt & Szymanski [11] 提出了一个花费$O((R+ N) lgN)$时间的算法，参数$R$是两个输入字符串匹配的有序对位置的总数。注意到就对$N$而言，这些算法都是$Ω(N^2)$。

　　在实际情况下，参数$D$通常较小。程序员想知道他们怎么改变过一个文本文件。生物学家想知道一条DNA链是如何突变为另一条的。$O(ND)$时间算法比Hirschberg的算法更加优越，因为$L$是$O(N)$的，而$D$是较小的。此外，Hunt and Szymanski [11] 的方法是基于$R$在实际中较小的假设上的。虽然在许多情况下这种假设是成立的，但必须注意到$R$与输入和输出的大小是无关的，所以在很多情况下，该算法可能是$O(N^2)$的。例如，在一个文件中有$10\%$的空行，将该文件与自身进行比对，$R$是大于$0.1N^2$的。对于DNA分子，字符集大小是4，这意味着当一个分子与自身或是非常相似的一个分子进行比对时，$R$至少是$0.25N^2$。

　　本文给出了一个$O(ND)$的算法。我们的算法是简单的，基于一个直观的形式化编辑图。与其它方法不同的是，它采用了"贪婪"的设计范式，将最长公共子序列问题与单源最短路径联系起来。另一个$O(ND)$算法在别处给出[16]。但是，它使用了不同的设计范式，并且不共享以下特性。算法可以被改进到只使用线性空间，其期待情况的时间为$O(N+D^2)$。此外，算法允许一个最坏情况$O(NlgN+D^2)$时间的变体。当$D$是$o(N)$，它在渐进性上比前面的算法[8,16,20]更加优越。

　　除了最坏情况$O(NlgN+D^2)$的变体，本文提出的算法是实用的。基本的$O(ND)$算法被作为UNIX diff 程序[15]新的实现基础。该版本的通常比system 5基于Hunt and Szymanski的算法[10]快两到四倍。但是，当$D$较大时，他们的算法是更加优越的（例如，当文件完全不同时，$R=0$并且$D=2N$。改进的线性空间的算法速度大概是基础算法$O(ND)$的两倍，但仍然具有竞争力，因为它可以执行超出其它算法范围的极大的比较，例如，即使差异大于500，两个1500000字节序列在两分钟内完成比较（在运行4.2BSD UNIX的VAX 785上) 。

## 2.编辑图
　　假设$A = a_1 a_2 . . . a_N$并且$ B = b_1 b_2 . . . b_M$，$A$和$B$分别是长度为$N$和$M$的序列。$A$和$B$的**编辑图（edit graph）**在每一个网格(x,y),$x\in[0,N]$并且$y\in[0,M]$上有一个顶点。用水平，垂直，和对角线有向边连接编辑图的每一个顶点，组成一个有向无环图。**水平边（Horizontal edges）**连接每个顶点和它的右邻居，例如，$(x-1,y)\rightarrow(x,y),x\in[1,N],y\in[0,M]$。**垂直边（Vertical edges）**连接每一个顶点和它下方的邻居。例如，$(x,y-1)\rightarrow(x,y),x\in[0,N],y\in[1,M]$。如果$a_x=b_y$，有一个**对角线边（diagonal edge）**连接顶点$(x-1,y-1)$到顶点$(x,y)$。当$a_x=b_y$，点$(x,y)$叫做**匹配点（match points）**。A与B之间所有的匹配点数量就是Hunt & Szymanski算法[11]的参数R。它也是编辑图中的与匹配点一一对应的对角线数量。图1描绘了序列$A = abcabba$ 和 $B = cbabac$的编辑图。

![figure-1](https://github.com/MouJieQin/mydiff/wiki/figure.1.an-edit-graph.png)

​                                                                              **图1** 一个编辑图

　　一条长度为L的**迹线（trace）**是一个有L个匹配点的序列，$(x_1,y_1)(x_2,y_2) … (x_L,y_L)$，同时对连续的点$(x_i,y_i)$和$(x_{i+1},y_{i+1}),i\in[0,L-1]$，满足$x_i<x_{i+1}$，并且$y_i<y_{i+1}$。每一条迹线都与编辑图中从$(0,0)$到$(N,M)$的路径中的对角线边准确对应。从开始到结束遍历一条路径的匹配点产生序列很容易被证明为一条迹线。注意L是对应路径的对角线的数量。要从迹线构造一条路径，将迹线的匹配点序列对应的对角线使用一系列的水平边和垂直边逐次连接起来。因为对于连续的匹配点$x_i<x_{i+1}$并且$y_i<y_{i+1}$，该操作总是可以完成。请注意，对于给定的迹线产生的若干路径，它们只在非对角线边有所区别。图1阐述了路径和迹线两者间的联系。

　　一个字符串的**子序列（subsequence）**是从给定字符串删除零个或多个字符而获得的任意字符串。两个字符串$A$，$B$的一个**公共子序列（common subsequence ）**是两者的子序列。每个迹线都可以生成一个公共子序列，反之亦然。具体而言，$a_{x_{1}}a_{x_{2}}...a_{x_{L}}=b_{y_{1}} b_{y_{2}}…b_{y_{L}}$是$A$与$B$的公共子序列，当且仅当$(x_1,y_1)(x_2,y_2)..(x_L,y_L)$是A与B的迹线。

　　$A$和$B$的**编辑脚本（edit script）**是从A转化成B的一个插入和删除命令的集合。**删除命令（delete command）**"$xD$"从$A$中删除符号$a_x$。**插入命令（insert command）**"$x I b_1,b_2,…b_t $"在A序列的$a_x$之后插入符号$b_1…b_t$。脚本中的A序列的符号位置是在任意命令执行之前的位置。必须考虑到脚本中的命令是同时执行的。脚本的长度是删除和插入符号的数量。

　　每一个迹线都唯一对应一个编辑脚本。设$(x_1,y_1)(x_2,y_2)…(x_L,y_L)$是一个迹线。设$y_0=0$并且$y_{L+1}=M+1$。其对应的脚本由以下命令组成："$xD$"，其中$x\notin\{x_1,x_2,…,x_L\}$，并且"$x_kIb_{y_k+1},…,b_{y_{K+1}-1}$"，其中k满足$y_{k}+1<y_{k+1}$（其非形式化的表述为：将所有不在迹线中的横坐标对应的A中的符号删掉，将所有不在迹线中的纵坐标对应的$B$中的符号插入）。脚本删除$N-L$个符号并且插入$M-L$个符号。所以对每一个长度为$L$的迹线对应的脚本长度$D=N+M-2L$。将脚本映射到一个迹线，在$A$上执行所有的删除命令。观察到结果是$A$和$B$的公共子序列，子序列映射到其唯一的迹线。注意到将给定集合的插入命令反转为删除命令映射到$B$集合上将产生相同的公共子序列。

　　在编辑脚本中，公共子序列，编辑脚本，迹线，从$(0,0)$到$(N,M)$的路径是形式化同构的。每一个路径的边就对应的公共子序列和编辑脚本而言，都有以下的直接解释。每一个以$(x,y)$结尾的对角线边都标志$a_x=b_y$，并在公共子序列中；每一个到$(x,y)$的水平边都对应着删除指令"xD";一个从$(x,y)$到$(x，z)$的垂直边序列对应着插入指令"$xIb_{y+1},…,b_z$"。因此，在路径中水平和垂直边的数量是它对应的脚本的长度，对角线的数量是其对应子序列的长度，并且所有边的数量为$N+M-L$。图1说明了这些结论。

　　寻找**最长公共子序列（longest common subsequence (LCS)）**问题与找到从$(0,0)$到$(M,N)$具有最大数量的对角线边的路径是等价的。寻找**最短编辑脚本（shortest edit script (SES)）**问题与找到从$(0,0)$到$(M,N)$具有最小数量的非对角线边的路径是等价的。它们是对偶问题，因为一个具有最大对角线边的路径具有最小数量的非对角线边（$D+2L = M+N$）。考虑在每条边上增加一个权重或者开销。给对角线边权重0，非对角线权重1。LCS/SES问题和在权重编辑图上寻找从$(0,0)$到$(x,y)$最小开销路径是等价的，因此，它是单源最短路径问题的一个特殊实例。

## 3.一个$O((M+N)D)$的贪婪算法

　　寻找最短编辑脚本的问题可以归结为寻找一条具有最小水平和垂直边的从$(0,0)$到$(N,M)$的路径。设一条**D-路径**是一条从$(0,0)$开始，正好有D个非对角线边的路径。一个0-路径必须只由对角线边组成。通过一个简单的归纳，一条D-路径必须由一条(D-1)-路径跟随一个非对角线边，和一个叫做**蛇（snake）**的可能为空的对角线边序列组成。

　　对编辑图网格中的对角线进行编号，使对角线$k$由$x−y=k$的点$(x，y)$组成。在此定义下，对角线的标号从$-M$到$N$。请注意，一个起点在对角线k的垂直边(水平边)的终点在对角线$k-1(k+1)$上，而蛇仍在它起点的对角线上。

**引理 1**：一条D-路径一定在对角线k上终止，其中$k\in\{-D,-D+2,…D\}$

**证明**：

　　一条0-路径只能由对角线组成，并且起始与对角线0上。因此它必须终止于对角线0。归纳地假设一条D-路径必须终止于对角线k，其中k属于$\{-D,-D+2,…D-2,D\}$。每条(D+1)-路径由一个在对角线k上结束的前缀D-路径，一个结束在对角线$(k+1)$或$(k-1)$上的非对角线边，和一条肯定也结束在对角线$(k+1)$或$(k-1)$的蛇组成。遵循了每一条(D+1)-路径必须结束在$\{(-D)\pm1,(-D+2)\pm1,…(D-2)\pm1,(d)\pm1\}=\{-D-1,-D+1,…,D-1,D+1\}$。因此，由归纳法得出的结论是成立的。引理表明当$D$是奇数时，D-路径结束于奇数对角线，当$D$是偶数时，D-路径结束于偶数对角线。

　　一条D-路径在对角线$k$上是**最远到达（furthest reaching）**的，当且仅当它是终点在对角线$k$上，并且有最大可能的行(列)数的D-路径之一。非形式化地，它是所有结束于对角线k的D-路径中终点距离原点$(0,0)$最远的D-路径，下面的引理对最远到达的D-路径给出了一个归纳的定性，体现了一个贪婪原则：最远到达的D-路径是由最远到达的(D-1)-路径通过贪婪地扩展得到的。

**引理 2**：一条最远到达的0-路径结束于$(x,x)$，其中$x=min(z-1||a_z\neq b_z 或 z>M或z>N)$。在对角线k上最远到达的D-路径可以不失一般性地分解为在对角线$k-1$最远到达的(D-1)-路径，跟随一个水平边，再跟随一个最长可能得蛇，或者被分解为在对角线$(k+1)$上最远到达的(D-1)-路径，跟随一个垂直边，再跟随一个最长可能的蛇。

**证明**：
　　基准0-路径是不证自明的。如前所述，一条D-路径由一条(D-1)-路径，一条非对角线边，一条蛇组成。如果D-路径结束于对角线$k$，其肯定遵循(D-1)-路径结束于对角线$k\pm1$，依赖于先于"最终蛇“的是垂直边还是水平边。”最终蛇“肯定是最大的，因为如果蛇还能扩展，D-路径将不是最远到达的。假设(D-1)-路径在其对角线上不是最远到达的，但是一条（同一对角线上）更远到达的(D-1)-路径可以通过一个适当的非对角线移动与”最终蛇“连接起来。因此，D-路径总是可以按要求分解。

　　（这里首先假设了一条最远到达对角线k上的D-路径已经存在，两条(D-1)-路径一定可以通过一条水平边或垂直边到达对角线$k$，此时先不要扩展”最终蛇“，更远到达的(D-1)-路径到达对角线k的端点的x坐标（y坐标）一定比次远到达的端点大，所以当次远到达的端点扩展”最终蛇“时一定会经过更远到达的端点，我们总是可以用更远到达的(D-1)-路径替代次远到达的(D-1)-路径。注意，这里论证的是在同一条对角线（$k-1$或$k+1$）的两条(D-1)-路径，对于一条在对角线k上最远到达的D-路径，一定有一条在对角线（$k-1$或$k+1$）上最远到达(D-1)-路径是其组成的一部分，但由另一条在对角线（$k+1$或$k-1$）上的最远到达的(D-1)-路径组成的一条在对角线k上的D-路径不一定是D-路径在对角线$k$上能够最远到达的。）

　　在对角线$(k+1)$和$(k-1)$上分别给定最远到达的(D-1)-路径的终点，$(x^{'},y^{'}),(x^{''},y^{"})$。引理2给出了一个计算D-路径在对角线k上最远到达的终点的程序。即，取$(x^{'},y^{'}+1)$和$(x^{"}+1,y^{"})$中在对角线$k$上能够更远到达的点，然后跟随对角线直到不能这样做或者到达编辑图的边界。此外，通过引理1，D-路径结束的端点所在的对角线只有 $D+1$条。这启示了计算D-路径在相应的$D+1$条对角线的终点，通过连续增长$D$的值直到最远到达路径在对角线$N-M$上到达端点$(N,M)$。

```
For D ← 0 to (M+N) Do
	For k ← −D to D in steps of 2 Do
		Find the endpoint of the furthest reaching D-path in diagonal k.
		If (N,M) is the endpoint Then
			The D-path is an optimal solution.
			Stop
```

　　当遇到最小的$D$使得最远到达的D-路径到达$(N,M)$，上面的程序就会停止。这肯定会在外层循环终止之前停止，因为$D$肯定是小于等于$M+N$的。这条路径肯定会有最小数量的非对角线边。因此这是一个LCS/SES问题的解决方案。

​		下图2展示了算法的细节，使用了很多简单的优化。一个数组$V$，元素$V[-D],V[-D+2],…,V[D-2],V[D]$是最远到达的D-路径的终点。通过引理1，这个集合中的元素与外层循环的下一次迭代要存储的(D+1)-路径的终点是不相交的。因此数组$V$可以同时保存D-路径的终点和从它们计算出来的(D+1)-路径的终点。此外，只需要保存$x$就可以记录在对角线$k$上的终点$(x,y)$，因为已知$y$是等于$x-k$的。因此，$V$是一个整数数组，其中$V[k]$是在对角线$k$上最远到达的终点的行索引(横坐标)。

![figure-2](https://github.com/MouJieQin/mydiff/wiki/figure.2.the-greedly-LCS_SES-algorithm.png)

​                                                                              **图2** LCS/SES的贪婪算法

​		作为一个搜索D-路径$(D\leq MAX)$的实际问题的算法，当没有到达$(N,M)$的路径时，在14行，它会报告从$A$到$B$的任意编辑脚本肯定比$MAX$长。通过在上面的大纲上设置常量$MAX$为$M+N$，算法会保证找到LCS/SES的长度。图3展示了将该算法应用于图1中样例的搜索路径。请注意算法第1行虚设的终点，$(0,-1)$，用来寻找0-路径最远到达的端点。也请注意随着算法的推进，D-路径适当地延展了编辑图的左下边界。假设这个区域没有对角线，即可以正确处理这种边界情况。



![figure-3](https://github.com/MouJieQin/mydiff/wiki/figure.3.Furthest-reaching-paths.png)



​                                                                              **图3** 最远到达的路径

　　贪婪算法最多消耗$O((M+N)D)$的时间，行1和行14消耗$O(1)$时间。内层循环（行3）最多重复$(D+1)(D+2)/2$次，因为外层循环(行2)重复$D+1$次，内层循环的第$k$次迭代最多重复$k$次。除**while循环（行9）**外，内层循环中所有的行都只花费常数时间。因此行2-8和行10-13消耗$O(D^2)$时间。当扩展最远到达路径时，每条对角线边遍历一次，while循环迭代一次。但是最多只有$O((M+N)D)$条对角线边被遍历，因为所有的D-路径都在对角线$-D$和$D$之间，在这一区域内最多有$(2D+1)·min(N,M)$个点（该区域有$2D+1$条对角线，超过边界的虚拟点不会进入while循环，对角线上最多顶点的个数是行列数中较小的一个。）。因此算法总计需要$O((M+N)D)$时间。注意到只有行9，遍历蛇是限制步骤。算法的其余部分是$O(D^2)$时间的。此外，在实际情况下，阈值被设置为远小于$M+N$，算法花费绝不会超过$O((M+N)MAX)$的时间。

　　贪婪算法的搜索主要是跟踪最优的D-路径。但V中只保存了当前的最远到达集合的终点。因此，该算法只能在行12报告SES/LCS的长度。想要产生一个明确的路径方案，需要使用$O(D^2)$的空间存储在外层循环每次迭代后$V$的一份拷贝。设$V_d$为第d次迭代后$V$的拷贝。要列出从$(0,0)$到点$V_{d-1}[k+1]$的最优路径，取决于它是从$V_{d-1}[k+1]$跟随一个垂直边，再跟随一条最大蛇的末端，还是$V_{d-1}[k-1]$后跟随一条水平边，再跟随一条最大蛇的末端。具体而言，假设是$V_{d-1}[k-1]$，递归列出从$(0,0)$到该点的最优路径，然后列出对应的垂直边和到$V_d[k]$的最大蛇。当$d=0$时递归停止，此时列出从$(0,0)$到$(V_0[0],V_0[0])$的蛇。所以让$V_D[N-M]$作为初始化点的递归程序替代第12行，使用额外的$O(M+N)$时间和$O(D^2)$的空间，可以列出一条最优路径。在下一个章节中将会展示只需要$O(M+N)$空间的改进算法。

　　如第2节所述，LCS/SES问题可以看做是权重编辑图中一个单源最短路径的一个实例。这表明特化的Dijkstra算法[3]是一个有效算法。一个基础的练习显示了算法花费$O(ElgV)$时间，其中E是主题图中边的数量，$V$是顶点的数量。在编辑图中$E<3V$，因为每一个点的出度最多是3。此外，$lgV$来自于管理一个优先队列的开销。在这种情况下，优先队列将是属于$[0,M+N]$的整数，因为边的开销是0或1，并且到任意点的最长路径是$M+N$。在这些条件下，优先队列操作可以使用"桶(bucketing)"和链接表技术实现为常数时间。因此，在编辑图中，Dijkstra算法可以被特化对应于顶点数量的线性时间，即$(MN)$。最后的改进来源于注意到需要的是从源$(0,0)$到点$(M,N)$的最短路径。每迭代一个顶点，Dijkstra算法以增序确定了从原点到顶点的最小的距离。通过引理1，最多有$O((M+N)D)$的点比$(M,N)$到$(0,0)$的距离小，并且前面的改进减少每次迭代的开销到$O(1)$。因此算法一旦确定了到达$(M,N)$的最小距离就可以停止，这样做只花费$O((M+N)D)$的时间。

　　对于LCS/SES问题，已经给出了一个特化的Dijkstra算法，也给出了一个$O(ND)$时间的算法。生成的算法涉及一个相对复杂的离散优先级队列，该队列可能包含多达$O(ND)$项，即使在计算LCS/SES长度的情况下也是如此。虽然可以说进一步的改进引导了本文的简单算法，这种联系变得很薄弱，以至于本节中直接而简单的目的推导更可取的。讨论的目的是去揭示在最短路径，LCS/SES问题和它们的算法之间的密切联系。

## 4.精炼

　　基础算法可以在很多方面得到改进。首先，算法期待的性能是$O(M+N+D^2)$，比最坏情况预测的$O((M+N)D)$要好得多。虽然这里没有显示，但实验显示，平均值的方差很小，特别是当字符表的大小变大时。因此，要求$O((M+N)D)$时间的病态情况是是极为罕见的（比如，像快速排序的$O(N^2)$问题）。第二，算法可以改进到只使用线性空间其报告一个编辑脚本。其它唯一被证明有这种改进的是一个基础的$O(MN)$动态规划算法[7]。线性空间算法拥有重要的实用价值，因为许多问题可以合理的在$O(D^2)$时间解决，而不是用$O(D^2)$的空间。最后，使用一些以前开发出的技术[6,14]来加速遍历蛇可以得到$O( (M + N) lg(M + N) + D^2)$最坏时间的变体。由于构成变体的底层方法的复杂性，变体是不切实际的，但它在最坏情况下的渐进最优性具有理论价值。

### 4a.概率分析

　　考虑下面序列$A$与$B$的最短编辑脚本问题的随机模型。$A$与$B$是字符集$\Sigma$上的序列，其中每个字符出现的概率为$p_\sigma,\sigma\in\Sigma$。$A$的$N$个字符是根据概率密度$p_\sigma$随机独立选择的。序列$B$的$M=N-\delta-\iota$个字符是通过从A中随机删除$\delta$个字符，随机插入$\iota$个随机选择的字符获得的。插入和删除位置的选择是均匀概率的。一个等价的模型是生成一个长度为$L=N-\delta$的随机序列，然后分别随机插入$\delta$和$\iota$个随机生成的字符到这个序列中去生成$A$和$B$。注意到$A$和$B$的LCS肯定至少由$L$个符号组成，但可能更长。

　　一个候选模型是考虑随机生成的长度为$N$和$M$的$A$和$B$序列，它们有长度为$L$的$LCS$的约束。这种模型与上面的任一模型都不等价，除非$\Sigma$具有任意大小，使得每一个概率$p_\sigma$趋于0。尽管如此，随后的处理也可以用同样的渐近结果应用于这个模型。选择第一个模型是因为它反映了SES问题所假定的将A映射到B的编辑脚本问题。但是其它的编辑脚本指令，像，"转变"，"移动"，"交换"，更能反映一个实际的编辑会话。包含它们的结果导致了与这里讨论的SES问题是不同的优化问题。因此基于这个编辑过程的随机模型是不被考虑的。

　　在A与B的编辑图中，有L个对角线边与$A$和$B$随机产生的LCS相对应。任意其它结束在$(x,y)$的对角线边，$a_x=b_y$有相同的发生概率，因为这些符号是通过随机独立实验产生的。因此非LCS对角线的概率为$\rho=\sum_{\sigma\in\Sigma}p_\sigma^2$。SES算法扩展搜索最远到达路径直到到达点$(N,M)$。每次扩展由一条水平边或是垂直边跟随一条最长可能得蛇组成。最大蛇由LCS和非LCS对角线边组成。给定一条扩展的蛇，正好有t个非LCS对角线边的概率为$\rho^t(1-\rho)$。在一个扩展里的非LCS的对角线数量的期望为$\sum_{t=0}^\infty t\rho^t(1-\rho)=\rho/(1-rho)$。SES算法外层For循环的第d次迭代最多有$d+1$个扩展。因此在期望情况下最多有$(D+1)(D+2)\rho/2(1-\rho)$个非LCS对角线被遍历。此外，最多有L个LCS对角线被遍历。但$\rho$远离1时，算法中关键的while循环平均执行$O(L+D^2)$次。算法的其余部分已经被观察到最坏耗费$O(D^2)$时间。当$pho=1$时，在字符集$\Sigma$中只有一个非零概率字符，所以A和B必定由这个字符重复组成。在这种情况下，算法运行在$O(M+N)$时间。因此，期望情况下SES算法耗费$O(M+N+D^2)$的时间。

### 4b.一个线性空间的改进

　　LCS/SES问题相对于编辑图边的方向是对称的。考虑反转A和B的编辑图中每条边的方向。$A$和$B$的子序列和编辑脚本在这个反转编辑图中是仍然可建模的，即使现在路径开始于$(N,M)$，结束于$(0,0)$。而且对路径的解释也只有轻微的改变以反映方向的改变。每条开始于$(x,y)$的对角线边都标志$a_x=b_y$，属于公共子序列；每一个从$(x,y)$开始的水平边都对应着一个删除命令"xD";等。所以LCS/SES问题可以通过在反向编辑图中从$(N,M)$开始，逐步扩展最远到达路径直到其中一条到达$(0,0)$。此后，前向路径将在编辑图中参考这些规则，反向路径将在反向编辑图中参考这些规则。因为反向路径是完全对应的，只有当操作重要时才需要区分路径方向。

　　在Hirschberg的线性空间算法[7]中，采用了分治策略。一条D-路径有$D+1$条蛇，其中一些可能是空的。划分步骤要求找到最优D-路径的$\lceil D/2\rceil+1$或者一条中间蛇。这样做的想法是同时运行正向和反向的基础算法，直到它们在对角"重叠"。下面的引理3提供了一个形式化的结论。

**引理3**：从$(0,0)$到$(N,M)$存在一条D-路径，当且仅当有一条从$(0,0)$到某点$(x,y)$的$\lceil D/2\rceil$-路径，并且有一条从某点$(u,v)$到$(N,M)$的$\lfloor D/2\rfloor$-路径，并满足：
$
(feasibility)\qquad u+v\geq \lceil D/2\rceil\quad and\quad x+y\leq N+M-\lfloor D/2 \rfloor\quad and\\
(overlap)\qquad x-y=u-v\ and x\geq u.\\
$
　　此外，所有的$(D/2)$-路径都被包含在从$(0,0)$到$(N,M)$的D-路径中。

**证明**：

　　假设存在一条从$(0,0)$到$(N,M)$的D-路径，当$(u,v)=(x,y)$时，它可以被划分成从$(0,0)$到$(x,y)$的$\lceil D/2 \rceil$-路径和一条从$(u,v)$到$(N,M)$的$\lfloor D/2\rfloor$-路径。从$(0,0)$到$(u,v)$的路径最多有$u+v$条非对角线边，而有一条$\lceil D/2 \rceil$-路径意味着$u+v\geq\lceil D/2\rceil$。一条从$(x,y)$到$(N,M)$的路径最多可以有$(N+M)-(x+y)$条非对角线边，而有一条$\lfloor D/2\rfloor$-路径到$(x,y)$意味着$x+y\leq N+M-\lfloor D/2\rfloor$。最终，$u-v=x-y$并且$u\leq x$，因为$(x,y)=(u,v)$。(上面证明了引理2命题中的前者是后者的充分条件，如果从$(0,0)$到$(N,M)$存在一条D-路径，那么有一条从$(0,0)$到某点$(x,y)$的$\lceil D/2\rceil$-路径，并且有一条从某点$(u,v)$到$(N,M)$的$\lfloor D/2\rfloor$-路径，其中的约束条件略去未写。)

(设$minD((u,v),(x,y))$为经过点$(u,v)$的$(x,y)$的最小D-路径的长度。

**引理4**（原文中并没有该引理）：对于点$(u,v)$和$(x,y)$,满足$u\leq x$且$v\leq y$。在任意情况下:
$
minD((u,v),(x,y)) \geq \begin{cases} minD((u,v),(u,v))+(v+x-y-u)\quad \quad u-v<x-y\\ 
minD((u,v),(u,v))\qquad\qquad\qquad\qquad\qquad  u-v=x-y \\
minD((u,v),(u,v))+(u-(x-y)-v)\quad \ u-v>x-y
\end{cases}
$
**证明**

　　经过$(u,v)$的$(x,y)$最短D-路径的长度为$(u,v)$的最短D-路径的长度加上从$(u,v)$到$(x,y)$的最短路径的非对角线边长度，设$L=min(x-u,y-v)$为两点之间的最大蛇的长度，从$(u,v)$到$(x,y)$的最短路径的非对角线边长度为$(x+y)-(u+v)-2L$。如果$u-v=x-y$，当有一条蛇连接$(u,v)$到$(x,y)$时，$L=x-u$，经过$(u,v)$的$(x,y)$最短D-路径的长度为$(u,v)$的最短D-路径长度,即$minD((u,v),(x,y)) \geq minD((u,v),(u,v))$。当$u-v<x-y$时，$L\leq y-v$，所以$minD((u,v),(x,y)) \geq minD((u,v),(u,v))$+(v+x-y-u)。同理可证当u-v>x-y时，$minD((u,v),(x,y)) \geq minD((u,v),(u,v))$+(u-(x-y)-v)。

**引理5**（原文中并没有该引理）：在编辑图中，$(x,y)$的最短D-路径的长度为$k$，点$(x+n,y+n)$，$x+n\leq N$并且$y+n\leq M$的最短D-路径的长度为$d$，则$k\leq d$。

**证明**：

　　如果存在一条蛇连接$(x,y)$和$(x+n,y+n)$,则$k=d$。由引理4可知，对于$(x+n,y+n)$的经过点$(x_i,y),x_i=i,0\leq i\leq x-1$的最短路径的非对角线长度$minD((x_i,y),(x+n,y+n))\geq minD((x_i,y),(x_i,y))+(y+(x+n)-(y+n)-x_i)$，由于$(x,y)$的最短D-路径的长度为$k$，所以$minD((x_i,y),(x_i,y))>=k-(x-x_i)$，所以$d=minD((x_i,y),(x+n,y+n))>=k$。同理可证，对于$(x+n,y+n)$经过点$(x,y_i),y_i=i,0\leq i \leq y-1$的最短路径的非对角线长度$d>=k$。$(x+n,y+n)$的D-路径必定经过上述各点，所以$k<=d$。)

　　反之，假设$\lceil D/2\rceil$-路径和$\lfloor D/2\rfloor$-路径存在（并满足约束条件）。但是$u\leq x$意味着有一条从$(0,0)$到$(u,v)$的k-路径，其中$k\leq \lceil D/2\rceil$（由引理5可知）。通过引理1，$\Delta =\lceil D/2\rceil-k$是2的倍数，因为k-路径和$\lceil D/2\rceil$-路径结束在相同的对角线上（所以k和$\lceil D/2 \rceil$具有相同的奇偶性）。此外，k-路径有$(u+v-k)/2\geq \Delta/2$条对角线，因为$u+v\leq\lceil D/2 \rceil$。通过使用一对水平边和垂直边替换k-路径中的$\Delta/2$条对角线边，将获得一条从$(0,0)$到$(u,v)$的$\lceil D/2\rceil$-路径。于是，这条从(0,0)到(u,v)的$\lceil D/2\rceil$-路径和一条给定的从$(u,v)$到$(N,M)$的$\lfloor D/2\rfloor$-路径便组成了一条从$(0,0)$到$(N,M)$的D-路径。请注意$\lfloor D/2\rfloor$-路径是D-路径的一部分。基于对称的原因，$\lceil D/2\rceil$-路径也是从$(0,0)$到$(N,M)$的D-路径的一部分。

　　(上面证明了引理2命题中的前者是后者的必要条件，如果有一条从$(0,0)$到某点$(x,y)$的$\lceil D/2\rceil$-路径，并且有一条从某点$(u,v)$到$(N,M)$的$\lfloor D/2\rfloor$-路径，那么从$(0,0)$到$(N,M)$存在一条D-路径。其中的约束条件略去未写。)

　　下面的大纲给出了一个寻找最优路径的中间蛇程序。对连续的D值，计算距离$(0,0)$最远到达的正向D-路径的终点，并且计算距离$(N,M)$最远到达的反向D-路径的终点。在V向量中像基础算法那样做，每个方向一个V向量。对每个计算出的终点，检查它是否在相同对角线的相反方向路径重叠。需要检查以确保在给定的对角线上有一个相反的路径，因为正向路径是以0为中心的对角线，而反向路径是以$\Delta=N−M$为中心的对角线。此外，根据引理1，编辑脚本的长度和$\Delta$具有相同的奇偶性。因此当$\Delta$是奇数时，只在扩展正向路径时检查是否重叠，当$\Delta$是偶数时，只在扩展反向路径时检查是否重叠。一旦一对反向的和最远到达的路径重叠，停止并报告重叠的蛇作为一条最优路径的中间蛇。请注意，这条蛇的端点可以很容易地交付，因为蛇刚刚在上一步被计算出来。

```
∆ ← N−M
For D ← 0 to 2 (M + N)/23 Do
	For k ← −D to D in steps of 2 Do
		Find the end of the furthest reaching forward D-path in diagonal k.
		If ∆ is odd and k ∈ [∆ − (D − 1) ,∆ + (D − 1)] Then
			If the path overlaps the furthest reaching reverse (D − 1)-path in diagonal k Then
				Length of an SES is 2D−1.
				The last snake of the forward path is the middle snake.
	For k ← −D to D in steps of 2 Do
		Find the end of the furthest reaching reverse D-path in diagonal k+∆.
			If ∆ is even and k + ∆ ∈ [ − D,D] Then
				If the path overlaps the furthest reaching forward D-path in diagonal k+∆ Then
					Length of an SES is 2D.
					The last snake of the reverse path is the middle snake.
```

　　这个程序的正确性重度依赖于引理3，不失一般性地假设$\Delta$是偶数，当一遇到最远到达的D-路径在相反方向重叠的最小的D，算法就会停止。首先，重叠路径肯定满足引理3的feasibility约束。假设最远到达的路径结束在$(u,v),u+v=k$。总是可以连接从$(0,0)$到$(u,v)$的非对角线的k-路径和反向的D-路径组成一条从$(0,0)$到$(N,M)$的(k+D)-路径。这条路径和引理3表明这里有一条重叠的h-路径。其中$h=(k+D)/2$（$k+D$是可以被2整除的，因为$\Delta$是偶数）。所以无疑这里有一条重叠的最远到达的h-or-less-路径。如果$k<D$，则$h<D$与最远到达的D-路径是第一个重叠的事实相矛盾，因此$u+v \geq D$。一个类似的论证表明，最远的到达前向D-路径也满足引理3的feasibility约束。现在可行性，重叠的D-路径和引理3意味着有一个长度为2D的路径的解，这肯定是最优的一个解，因为如果存在2k-路径，$k<D$，那么引理意味着有k-路径重叠，但是这意味着有重叠的最远到达的k-or-less-路径，与没有比$D$小的重叠的路径的事实相矛盾，所以$u+v\geq D$。通过引理3，所有的重叠路径都是从$(0,0)$到$(N,M)$的最优的2D-路径的一部分。当$\Delta$是奇数时，可以得出相同的结论。选择的蛇是最优路径一部分的中间蛇仍有待证明。当$\Delta$是奇数（偶数）时，这条蛇是正向（反向）路径的第$D+1$步，最优路径2D-1(2D)-路径一部分。

　　寻找最优D-路径的中间蛇程序的两个$V$向量需要总计$O(D)$的工作存储空间。程序只要求$O((M+N)D)$时间，因为正向和反向路径的扩展都是用消耗$O((M+N)D)$时间的使用相同参数的基本算法。事实上，在扩展正向和反向路径时遍历的蛇的数量只是基础算法的一半，因为只搜索了$D/2$条对角线。这个特性是实用的--实验表明，当$D=0$时，这种确定SES长度的方法与基本算法一样高效，而且随着D的增长，速度迅速增长为它的两倍。

　　给定一个中间蛇程序，通过编辑图，一个寻找大小分别为N和M的A和B序列的一条最优路径的线性空间算法可以被设计出来。为了简单，下面的分治算法只是列出了A和B的最长公共子序列。(生成最短编辑脚本保留为练习。)，首先，划分问题为寻找最优路径的从$(x,y)$到$(u,v)$的中间蛇。通过递归地寻找一条从$(0,0)$到$(x,y)$的$\lceil D/2\rceil$-路径，并且列出它们的LCS，来解决问题。然后列出中间蛇("Output $A[x..u]$",如果$u<x$,则没有输出)。最后，递归地寻找从(u,v)到(N,M)的$\lfloor D/2\rfloor$-路径并列出它们的LCS。递归以两种方式结束。如果N=0或者M=0，则L=0并且没有什么可列出的。在其它情况下，N>0并且M>0并且$D\leq 1$。如果$D\leq 1$，则B是通过删除或插入最多一个符号从A获得的。但是它遵循了A与B中较短的是LCS，并且应该被列出。

```
LCS(A,N,B,M)
	If N>0 and M>0 Then
		Find the middle snake and length of an optimal path for A and B.
		Suppose it is from (x,y) to (u,v).
		If D > 1 Then
			LCS(A[1..x],x,B[1..y],y)
			Output A[x+1..u].
			LCS(A[u+1..N],N−u,B[v+1..M],M−v)
		Else If M > N Then
			Output A[1..N].
		Else
			Output B[1..M].
```

后略。

### 4c.一个$O( (M + N) lg(M + N) + D^2)$最坏情况的变体

略。

##致谢

　　Webb Miller 最先提出了寻找$O(ND)$算法的问题。作者想要感谢他助力这项工作和他的许多有帮助的建议。审阅人的评论和更正使本文变得更好。

## 参考文献

1. Aho, A.V., Hirschberg, D.S., and Ullman, J.D. ‘‘Bounds on the Complexity of the Longest Common Subsequence Problem.’’ Journal of ACM 23, 1 (1976), 1-12.
2. Aho, A.V., Hopcroft, J.E., and Ullman, J.D. Data Structures and Algorithms. Addison-Wesley, Reading,
Mass. (1983), 203-208.
3. Dijkstra, E.W. ‘‘A Note on Two Problems in Connexion with Graphs.’’ Numerische Mathematik 1 (1959),
269-271.
4. Gosling, J. ‘‘A Redisplay Algorithm.’’ Proceedings ACM SIGPLAN/SIGOA Symposium on Text Manipulation (1981), 123-129.
5. Hall, P.A.V. and Dowling, G.R. ‘‘Approximate String Matching.’’ Computing Surveys 12, 4 (1980), 381-402.
6. Harel, D. and Tarjan, R.E. ‘‘Fast Algorithms for Finding Nearest Common Ancestors.’’ SIAM Journal on
Computing 13, 2 (1984), 338-355.
7. Hirschberg, D.S. ‘‘A Linear Space Algorithm for Computing Maximal Common Subsequences.’’ Communications of ACM 18, 6 (1975), 341-343.
8. Hirschberg, D.S. ‘‘Algorithms for the Longest Common Subsequence Problem.’’ Journal of ACM 24, 4
(1977), 664-675.
9. Hirschberg, D.S. ‘‘An Information-Theoretic Lower Bound for the Longest Common Subsequence Problem.’’
Information Processing Letters 7, 1 (1978), 40-41.
10. Hunt, J.W. and McIlroy, M.D. ‘‘An Algorithm for Differential File Comparison.’’ Computing Science Technical Report 41, Bell Laboratories (1975).
11. Hunt, J.W. and Szymanski, T.G. ‘‘A Fast Algorithm for Computing Longest Common Subsequences.’’ Communications of ACM 20, 5 (1977), 350-353.
12. Knuth, D.E. The Art of Computer Programming, Vol. 3: Sorting and Searching. Addison-Wesley, Reading,
Mass. (1983), 490-493.
13. Masek, W.J. and Paterson, M.S. ‘‘A Faster Algorithm for Computing String Edit Distances.’’ J. of Computer
and Systems Sciences 20, 1 (1980), 18-31.
14. McCreight, E.M. ‘‘A Space-Economical Suffix Tree Construction Algorithm.’’ Journal of ACM 23, 2 (1976),
262-272.
15. Miller, W., and Myers, E.W. ‘‘A File Comparison Program.’’ Software — Practice & Experience 15, 11
(1985), 1025-1040.
16. Nakatsu, N., Kambayashi, Y., and Yajima, S. ‘‘A Longest Common Subsequence Algorithm Suitable for
Similar Text Strings.’’ Acta Informatica 18 (1982), 171-179.
17. Rochkind, M.J. ‘‘The Source Code Control System.’’ IEEE Transactions on Software Engineering 1, 4
(1975), 364-370.
18. Sankoff, D. and Kruskal, J.B. Time Warps, String Edits and Macromolecules: The Theory and Practice of
Sequence Comparison. Addison-Wesley, Reading, Mass. (1983).
19. Tichy, W. ‘‘The String-to-String Correction Problem with Block Moves.’’ ACM Transactions on Computer
Systems 2, 4 (1984), 309-321.
20. Wagner, R.A. and Fischer, M.J. ‘‘The String-to-String Correction Problem.’’ Journal of ACM 21, 1 (1974),
168-173.



Email:        moujieqin@gmail.com

