#一种O(ND)的差分算法和其变体

#### 作者：	`EUGENE W. MYERS`

## 摘要

  求两个序列$$A$$、$$B$$的最长公共子序列，和把$$A$$转换成$$B$$的最短编辑脚本一直被认为是双重问题。在本文中，它们被证明等价于在编辑图中找到最长或最短的路径。通过透视图，一个简单的$$O(ND)$$的时间和空间算法被开发出来，其中$$N$$是$$A$$、$$B$$长度之和，$$D$$是最小编辑脚本的长度。当两个序列差异较小(序列相似)时，该算法性能很好，因此在典型应用中具有较快的速度。在基本随机模型下，该算法显示出$$O(N+D^2)$$的期待时间性能。一种改进算法只要求$$O(N)$$的空间，使用后缀树产生一个$$O(NlgN+D^2)$$时间的变体。

#### 关键词 

最长公共子序列 最短编辑脚本 编辑图 文件比对

## 1.导言

  确定两个符号序列之间的差异问题已经被广泛研究[1，8，11，13，16，19，20] （此为文献引用标号，下同）。该问题的算法有许多应用，包括拼写更正系统，文件比对工具，和遗传进化研究[4，5，17，18]。形式化的问题表述为：寻找最长公共子序列，或者等价地，找到将一个序列转变为另一个的最小删除和插入符号的脚本。最早的算法之一是由Wagner & Fischer [20] 提出的花费$O(N^2)$的时间和空间，解决他们称为 string-to-string correction (字符串到字符串校正) 的泛化问题。Hirschberg [7]随后发表了只使用线性空间找到最长公共子序列的改进算法。已被证明，算法在任意字符表上，使用”equal—unequal“ (相等-不等)比较，以它们的输入大小作为特征值，$Ω(N
2
) $时间的花费是必须的[1]。一个称为"Four Russians"的方法在任意和限定字符集上分别促成了稍好的$O(N^2lglgN/lgN)$ 和 $O(N^2/lgN)$ 时间算法[13]。使用其它比较形式的更快算法仍然存在余地。实际上，使用"‘less than—equal—greater than" (小于-等于-大于)的比较方法，已知的最低时间边界为$Ω(NlgN)$ [9]。

  最近的工作在任意字符集的$O(N^2)$时间的基础算法上对其它敏感参数做了改进。设输出参数$L$为最长公共子序列的长度，并将对偶参数$D=2(N-L)$设为最短编辑脚本的长度。(在整个导言中假设两个字符串都有相同的字长度$N$。) Hirschberg [8] 提出了$O(NL + NlgN)$ 和 $O(DLlgN)$时间两个最佳输出-敏感算法，Hunt & Szymanski [11] 提出了一个花费$O((R+ N) lgN)$时间的算法，参数$R$是两个输入字符串匹配的有序对位置的总数。注意到就对$N$而言，这些算法都是$Ω(N^2)$。

  在实际情况下，参数$D$通常较小。程序员想知道他们怎么改变过一个文本文件。生物学家想知道一条DNA链是如何突变为另一条的。$O(ND)$时间算法比Hirschberg的算法更加优越，因为$L$是$O(N)$的，而$D$是较小的。此外，Hunt and Szymanski [11] 的方法是基于$R$在实际中较小的假设上的。虽然在许多情况下这种假设是成立的，但必须注意到$R$与输入和输出的大小是无关的，所以在很多情况下，该算法可能是$O(N^2)$的。例如，在一个文件中有$10\%$的空行，将该文件与自身进行比对，$R$是大于$0.1N^2$的。对于DNA分子，字符集大小是4，这意味着当一个分子与自身或是非常相似的一个分子进行比对时，$R$至少是$0.25N^2$。

  本文给出了一个$O(ND)$的算法。我们的算法是简单的，基于一个直观的形式化编辑图。与其它方法不同的是，它采用了"贪婪"的设计范式，将最长公共子序列问题与单源最短路径联系起来。另一个$O(ND)$算法在别处给出[16]。但是，它使用了不同的设计范式，并且不共享以下特性。算法可以被改进到只使用线性空间，其期待情况的时间为$O(N+D^2)$。此外，算法允许一个最坏情况$O(NlgN+D^2)$时间的变体。当$D$是$o(N)$，它在渐进性比前面的算法[8，16，20]更加优越。

  除了最坏情况$O(NlgN+D^2)$的变体，本文提出的算法是实用的。基本的$O(ND)$算法被作为UNIX diff 程序[15]新的实现基础。该版本的通常比system 5基于Hunt and Szymanski的算法[10]快两到四倍。但是，当$D$较大时，他们的算法是更加优越的（例如，当文件完全不同时，$R=0$并且$D=2N$。改进的线性空间的算法速度大概是基础算法$O(ND)$的两倍，但仍然具有竞争力，因为它可以执行超出其它算法范围的极大的比较，例如，即使差异大于500，两个1500000字节序列在两分钟内完成比较（在运行4.2BSD UNIX的VAX 785上) 。

## 2.编辑图

  假设$A = a_1 a_2 . . . a_N$并且$ B = b_1 b_2 . . . b_M$，$A$和$B$分别是长度为$N$和$M$的序列。A和B的**编辑图（edit graph）**在每一个网格(x,y),$x\in[0,N]$并且$y\in[0,M]$上有一个顶点。用水平，垂直，和对角线有向边连接编辑图的每一个顶点，组成一个有向无环图。**水平边（Horizontal edges）**连接每个顶点和它的右邻居，例如，$(x-1,y)\rightarrow(x,y),x\in[1,N],y\in[0,M]$。**垂直边（Vertical edges）**连接每一个顶点和它下方的邻居。例如，$(x,y-1)\rightarrow(x,y),x\in[0,N],y\in[1,M]$。如果$a_x=b_y$，有一个**对角线边（diagonal edge）**连接顶点$(x-1,y-1)$到顶点$(x,y)$。当$a_x=b_y$，点$(x,y)$叫做**匹配点（match points）**。A与B之间所有的匹配点数量就是Hunt & Szymanski算法[11]的参数R。它也是编辑图中的与匹配点一一对应的对角线数量。图1描绘了序列A = abcabba 和 B = cbabac的编辑图。

![figure-1](https://github.com/MouJieQin/mydiff/wiki/figure.1.an-edit-graph.png)

​                                                                              **图1** 一个编辑图

  一条长度为L的**迹线（trace）**是一个有L个匹配点的序列，$(x_1,y_1)(x_2,y_2) … (x_L,y_L)$，同时对连续的点$(x_i,y_i)$和$(x_{i+1},y_{i+1}),i\in[0,L-1]$，满足$x_i<x_{i+1}$，并且$y_i<y_{i+1}$。每一条迹线都与编辑图中从(0,0)到(N,M)的路径中的对角线边准确对应。从开始到结束遍历一条路径的匹配点产生序列很容易被证明为一条迹线。注意L是对应路径的对角线的数量。要从迹线构造一条路径，将迹线的匹配点序列对应的对角线使用一系列的水平边和垂直边逐次连接起来。因为对于连续的匹配点$x_i<x_{i+1}$并且$y_i<y_{i+1}$，该操作总是可以完成。请注意，对于给定的迹线产生的若干路径，它们只在非对角线边有所区别。图1阐述了路径和迹线两者间的联系。

  一个字符串的**子序列（subsequence）**是从给定字符串删除零个或多个字符而获得的任意字符串。两个字符串A，B的一个**公共子序列（common subsequence ）**是两者的子序列。每个迹线都可以生成一个公共子序列，反之亦然。具体而言，$a_{x_{1}}a_{x_{2}}...a_{x_{L}}=b_{y_{1}} b_{y_{2}}…b_{y_{L}}$是A与B的公共子序列，当且仅当$(x_1,y_1)(x_2,y_2)..(x_L,y_L)$是A与B的迹线。

  A和B的**编辑脚本（edit script）**是从A转化成B的一个插入和删除命令的集合。**删除命令（delete command）**"$xD$"从A中删除符号$a_x$。**插入命令（insert command）**"$x I b_1,b_2,…b_t $"在A序列的$a_x$之后插入符号$b_1…b_t$。脚本中的A序列的符号位置是在任意命令执行之前的位置。必须考虑到脚本中的命令是同时执行的。脚本的长度是删除和插入符号的数量。

  每一个迹线都唯一对应一个编辑脚本。设$(x_1,y_1)(x_2,y_2)…(x_L,y_L)$是一个迹线。设$y_0=0$并且$y_{L+1}=M+1$。其对应的脚本由以下命令组成："$xD$"，其中$x\notin\{x_1,x_2,…,x_L\}$，并且"$x_kIb_{y_k+1},…,b_{y_{K+1}-1}$"，其中k满足$y_{k}+1<y_{k+1}$（其非形式化的表述为：将所有不在迹线中的横坐标对应的A中的符号删掉，将所有不在迹线中的纵坐标对应的B中的符号插入）。脚本删除$N-L$个符号并且插入$M-L$个符号。所以对每一个长度为L的迹线对应的脚本长度$D=N+M-2L$。将脚本映射到一个迹线，在A上执行所有的删除命令。观察到结果是A和B的公共子序列，子序列映射到其唯一的迹线。注意到将给定集合的插入命令反转为删除命令映射到B集合上将产生相同的公共子序列。

  在编辑脚本中，公共子序列，编辑脚本，迹线，从$(0,0)$到$(N,M)$的路径是形式化同构的。每一个路径的边就对应的公共子序列和编辑脚本而言，都有以下的直接解释。每一个以$(x,y)$结尾的对角线边都标志$a_x=b_y$，并在公共子序列中；每一个到(x,y)的水平边都对应着删除指令"xD";一个从(x,y)到(x，z)的垂直边序列对应着插入指令"$xIb_{y+1},…,b_z$"。因此，在路径中水平和垂直边的数量是它对应的脚本的长度，对角线的数量是其对应子序列的长度，并且所有边的数量为$N+M-L$。图1说明了这些结论。

  寻找**最长公共子序列（longest common subsequence (LCS)）**问题与找到从(0,0)到(M,N)具有最大数量的对角线边的路径是等价的。寻找**最短编辑脚本（shortest edit script (SES)）**问题与找到从(0,0)到(M,N)具有最小数量的非对角线边的路径是等价的。它们是对偶问题，因为一个具有最大对角线边的路径具有最小数量的非对角线边（$D+2L = M+N$）。考虑在每条边上增加一个权重或者开销。给对角线边权重0，非对角线权重1。LCS/SES问题和在权重编辑图上寻找从(0,0)到(x,y)最小开销路径是等价的，因此，它是单源最短路径问题的一个特殊实例。





##### 



