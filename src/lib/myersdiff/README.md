#一个$O(ND)$的差分算法及其变体

#### 作者：	`EUGENE W. MYERS`

## 摘要
　　求两个序列$$A$$、$$B$$的最长公共子序列，和把$$A$$转换成$$B$$的最短编辑脚本一直被认为是双重问题。在本文中，它们被证明等价于在编辑图中找到最长或最短的路径。通过透视图，一个简单的$$O(ND)$$的时间和空间算法被开发出来，其中$$N$$是$$A$$、$$B$$长度之和，$$D$$是最小编辑脚本的长度。当两个序列差异较小(序列相似)时，该算法性能很好，因此在典型应用中具有较快的速度。在基本随机模型下，该算法显示出$$O(N+D^2)$$的期待时间性能。一种改进算法只要求$$O(N)$$的空间，使用后缀树产生一个$$O(NlgN+D^2)$$时间的变体。

#### 关键词 

最长公共子序列 最短编辑脚本 编辑图 文件比对

## 1.导言

　　确定两个符号序列之间的差异问题已经被广泛研究[1，8，11，13，16，19，20] （此为文献引用标号，下同）。该问题的算法有许多应用，包括拼写更正系统，文件比对工具，和遗传进化研究[4，5，17，18]。形式化的问题表述为：寻找最长公共子序列，或者等价地，找到将一个序列转变为另一个的最小删除和插入符号的脚本。最早的算法之一是由Wagner & Fischer [20] 提出的花费$O(N^2)$的时间和空间，解决他们称为 string-to-string correction (字符串到字符串校正) 的泛化问题。Hirschberg [7]随后发表了只使用线性空间找到最长公共子序列的改进算法。已被证明，算法在任意字符表上，使用”equal—unequal“ (相等-不等)比较，以它们的输入大小作为特征值，$Ω(N
2
) $时间的花费是必须的[1]。一个称为"Four Russians"的方法在任意和限定字符集上分别促成了稍好的$O(N^2lglgN/lgN)$ 和 $O(N^2/lgN)$ 时间算法[13]。使用其它比较形式的更快算法仍然存在余地。实际上，使用"‘less than—equal—greater than" (小于-等于-大于)的比较方法，已知的最低时间边界为$Ω(NlgN)$ [9]。

　　最近的工作在任意字符集的$O(N^2)$时间的基础算法上对其它敏感参数做了改进。设输出参数$L$为最长公共子序列的长度，并将对偶参数$D=2(N-L)$设为最短编辑脚本的长度。(在整个导言中假设两个字符串都有相同的字长度$N$。) Hirschberg [8] 提出了$O(NL + NlgN)$ 和 $O(DLlgN)$时间两个最佳输出-敏感算法，Hunt & Szymanski [11] 提出了一个花费$O((R+ N) lgN)$时间的算法，参数$R$是两个输入字符串匹配的有序对位置的总数。注意到就对$N$而言，这些算法都是$Ω(N^2)$。

　　在实际情况下，参数$D$通常较小。程序员想知道他们怎么改变过一个文本文件。生物学家想知道一条DNA链是如何突变为另一条的。$O(ND)$时间算法比Hirschberg的算法更加优越，因为$L$是$O(N)$的，而$D$是较小的。此外，Hunt and Szymanski [11] 的方法是基于$R$在实际中较小的假设上的。虽然在许多情况下这种假设是成立的，但必须注意到$R$与输入和输出的大小是无关的，所以在很多情况下，该算法可能是$O(N^2)$的。例如，在一个文件中有$10\%$的空行，将该文件与自身进行比对，$R$是大于$0.1N^2$的。对于DNA分子，字符集大小是4，这意味着当一个分子与自身或是非常相似的一个分子进行比对时，$R$至少是$0.25N^2$。

　　本文给出了一个$O(ND)$的算法。我们的算法是简单的，基于一个直观的形式化编辑图。与其它方法不同的是，它采用了"贪婪"的设计范式，将最长公共子序列问题与单源最短路径联系起来。另一个$O(ND)$算法在别处给出[16]。但是，它使用了不同的设计范式，并且不共享以下特性。算法可以被改进到只使用线性空间，其期待情况的时间为$O(N+D^2)$。此外，算法允许一个最坏情况$O(NlgN+D^2)$时间的变体。当$D$是$o(N)$，它在渐进性比前面的算法[8，16，20]更加优越。

　　除了最坏情况$O(NlgN+D^2)$的变体，本文提出的算法是实用的。基本的$O(ND)$算法被作为UNIX diff 程序[15]新的实现基础。该版本的通常比system 5基于Hunt and Szymanski的算法[10]快两到四倍。但是，当$D$较大时，他们的算法是更加优越的（例如，当文件完全不同时，$R=0$并且$D=2N$。改进的线性空间的算法速度大概是基础算法$O(ND)$的两倍，但仍然具有竞争力，因为它可以执行超出其它算法范围的极大的比较，例如，即使差异大于500，两个1500000字节序列在两分钟内完成比较（在运行4.2BSD UNIX的VAX 785上) 。

## 2.编辑图
　　假设$A = a_1 a_2 . . . a_N$并且$ B = b_1 b_2 . . . b_M$，$A$和$B$分别是长度为$N$和$M$的序列。A和B的**编辑图（edit graph）**在每一个网格(x,y),$x\in[0,N]$并且$y\in[0,M]$上有一个顶点。用水平，垂直，和对角线有向边连接编辑图的每一个顶点，组成一个有向无环图。**水平边（Horizontal edges）**连接每个顶点和它的右邻居，例如，$(x-1,y)\rightarrow(x,y),x\in[1,N],y\in[0,M]$。**垂直边（Vertical edges）**连接每一个顶点和它下方的邻居。例如，$(x,y-1)\rightarrow(x,y),x\in[0,N],y\in[1,M]$。如果$a_x=b_y$，有一个**对角线边（diagonal edge）**连接顶点$(x-1,y-1)$到顶点$(x,y)$。当$a_x=b_y$，点$(x,y)$叫做**匹配点（match points）**。A与B之间所有的匹配点数量就是Hunt & Szymanski算法[11]的参数R。它也是编辑图中的与匹配点一一对应的对角线数量。图1描绘了序列A = abcabba 和 B = cbabac的编辑图。

![figure-1](https://github.com/MouJieQin/mydiff/wiki/figure.1.an-edit-graph.png)

​                                                                              **图1** 一个编辑图

　　一条长度为L的**迹线（trace）**是一个有L个匹配点的序列，$(x_1,y_1)(x_2,y_2) … (x_L,y_L)$，同时对连续的点$(x_i,y_i)$和$(x_{i+1},y_{i+1}),i\in[0,L-1]$，满足$x_i<x_{i+1}$，并且$y_i<y_{i+1}$。每一条迹线都与编辑图中从(0,0)到(N,M)的路径中的对角线边准确对应。从开始到结束遍历一条路径的匹配点产生序列很容易被证明为一条迹线。注意L是对应路径的对角线的数量。要从迹线构造一条路径，将迹线的匹配点序列对应的对角线使用一系列的水平边和垂直边逐次连接起来。因为对于连续的匹配点$x_i<x_{i+1}$并且$y_i<y_{i+1}$，该操作总是可以完成。请注意，对于给定的迹线产生的若干路径，它们只在非对角线边有所区别。图1阐述了路径和迹线两者间的联系。

　　一个字符串的**子序列（subsequence）**是从给定字符串删除零个或多个字符而获得的任意字符串。两个字符串A，B的一个**公共子序列（common subsequence ）**是两者的子序列。每个迹线都可以生成一个公共子序列，反之亦然。具体而言，$a_{x_{1}}a_{x_{2}}...a_{x_{L}}=b_{y_{1}} b_{y_{2}}…b_{y_{L}}$是A与B的公共子序列，当且仅当$(x_1,y_1)(x_2,y_2)..(x_L,y_L)$是A与B的迹线。

　　A和B的**编辑脚本（edit script）**是从A转化成B的一个插入和删除命令的集合。**删除命令（delete command）**"$xD$"从A中删除符号$a_x$。**插入命令（insert command）**"$x I b_1,b_2,…b_t $"在A序列的$a_x$之后插入符号$b_1…b_t$。脚本中的A序列的符号位置是在任意命令执行之前的位置。必须考虑到脚本中的命令是同时执行的。脚本的长度是删除和插入符号的数量。

　　每一个迹线都唯一对应一个编辑脚本。设$(x_1,y_1)(x_2,y_2)…(x_L,y_L)$是一个迹线。设$y_0=0$并且$y_{L+1}=M+1$。其对应的脚本由以下命令组成："$xD$"，其中$x\notin\{x_1,x_2,…,x_L\}$，并且"$x_kIb_{y_k+1},…,b_{y_{K+1}-1}$"，其中k满足$y_{k}+1<y_{k+1}$（其非形式化的表述为：将所有不在迹线中的横坐标对应的A中的符号删掉，将所有不在迹线中的纵坐标对应的B中的符号插入）。脚本删除$N-L$个符号并且插入$M-L$个符号。所以对每一个长度为L的迹线对应的脚本长度$D=N+M-2L$。将脚本映射到一个迹线，在A上执行所有的删除命令。观察到结果是A和B的公共子序列，子序列映射到其唯一的迹线。注意到将给定集合的插入命令反转为删除命令映射到B集合上将产生相同的公共子序列。

　　在编辑脚本中，公共子序列，编辑脚本，迹线，从$(0,0)$到$(N,M)$的路径是形式化同构的。每一个路径的边就对应的公共子序列和编辑脚本而言，都有以下的直接解释。每一个以$(x,y)$结尾的对角线边都标志$a_x=b_y$，并在公共子序列中；每一个到(x,y)的水平边都对应着删除指令"xD";一个从(x,y)到(x，z)的垂直边序列对应着插入指令"$xIb_{y+1},…,b_z$"。因此，在路径中水平和垂直边的数量是它对应的脚本的长度，对角线的数量是其对应子序列的长度，并且所有边的数量为$N+M-L$。图1说明了这些结论。

　　寻找**最长公共子序列（longest common subsequence (LCS)）**问题与找到从(0,0)到(M,N)具有最大数量的对角线边的路径是等价的。寻找**最短编辑脚本（shortest edit script (SES)）**问题与找到从(0,0)到(M,N)具有最小数量的非对角线边的路径是等价的。它们是对偶问题，因为一个具有最大对角线边的路径具有最小数量的非对角线边（$D+2L = M+N$）。考虑在每条边上增加一个权重或者开销。给对角线边权重0，非对角线权重1。LCS/SES问题和在权重编辑图上寻找从(0,0)到(x,y)最小开销路径是等价的，因此，它是单源最短路径问题的一个特殊实例。

## 3.一个$O((M+N)D)$的贪婪算法

　　寻找最短编辑脚本的问题可以归结为寻找一条具有最小水平和垂直边的从$(0,0)$到$(N,M)$的路径。设一条**D-路径**是一条从$(0,0)$开始，正好有D个非对角线边的路径。一个0-路径必须只由对角线边组成。通过一个简单的归纳，一条D-路径必须由一条(D-1)-路径跟随一个非对角线边，和一个叫做**蛇（snake）**的可能为空的对角线边序列组成。

　　对编辑图网格中的对角线进行编号，使对角线k由x−y=k的点(x，y)组成。在此定义下，对角线的标号从-M到N。请注意，一个起点在对角线k的垂直边(水平边)的终点在对角线k-1(k+1)上，而蛇仍在它起点的对角线上。

**引理 1**：一条D-路径一定在对角线k上终止，其中$k\in\{-D,-D+2,…D\}$

**证明**：

　　一条0-路径只能由对角线组成，并且起始与对角线0上。因此它必须终止于对角线0。归纳地假设一条D-路径必须终止于对角线k，其中k属于$\{-D,-D+2,…D-2,D\}$。每条(D+1)-路径由一个在对角线k上结束的前缀D-路径，一个结束在对角线(k+1)或(k-1)上的非对角线边，和一条肯定也结束在对角线(k+1)或(k-1)的蛇组成。遵循了每一条(D+1)-路径必须结束在$\{(-D)\pm1,(-D+2)\pm1,…(D-2)\pm1,(d)\pm1\}=\{-D-1,-D+1,…,D-1,D+1\}$。因此，由归纳法得出的结论是成立的。引理表明当D是奇数时，D-路径结束于奇数对角线，当D是偶数时，D-路径结束于偶数对角线。

　　一条D-路径在对角线k上是**最远到达（furthest reaching）**的，当且仅当它是终点在对角线k上，并且有最大可能的行(列)数的D-路径之一。非形式化地，它是所有结束于对角线k的D-路径中终点距离原点(0,0)最远的D-路径，下面的引理对最远到达的D-路径给出了一个归纳的定性，体现了一个贪婪原则：最远到达的D-路径是由最远到达的(D-1)-路径通过贪婪地扩展得到的。

**引理 2**：一条最远到达的0-路径结束于(x,x)，其中$x=min(z-1||a_z\neq b_z 或 z>M或z>N)$。在对角线k上最远到达的D-路径可以不失一般性地分解为在对角线k-1最远到达的(D-1)-路径，跟随一个水平边，再跟随一个最长可能得蛇，或者被分解为在对角线(k+1)上最远到达的(D-1)-路径，跟随一个垂直边，再跟随一个最长可能的蛇。

**证明**：
　　基准0-路径是不证自明的。如前所述，一条D-路径由一条(D-1)-路径，一条非对角线边，一条蛇组成。如果D-路径结束于对角线k，其肯定遵循(D-1)-路径结束于对角线$k\pm1$，依赖于先于"最终蛇“的是垂直边还是水平边。”最终蛇“肯定是最大的，因为如果蛇还能扩展，D-路径将不是最远到达的。假设(D-1)-路径在其对角线上不是最远到达的，但是一条（同一对角线上）更远到达的(D-1)-路径可以通过一个适当的非对角线移动与”最终蛇“连接起来。因此，D-路径总是可以按要求分解。

　　（这里首先假设了一条最远到达对角线k上的D-路径已经存在，两条(D-1)-路径一定可以通过一条水平边或垂直边到达对角线k，此时先不要扩展”最终蛇“，更远到达的(D-1)-路径到达对角线k的端点的x坐标（y坐标）一定比次远到达的端点大，所以当次远到达的端点扩展”最终蛇“时一定会经过更远到达的端点，我们总是可以用更远到达的(D-1)-路径替代次远到达的(D-1)-路径。注意，这里论证的是在同一条对角线（k-1或k+1）的两条(D-1)-路径，对于一条在对角线k上最远到达的D-路径，一定有一条在对角线（k-1或k+1）上最远到达(D-1)-路径是其组成的一部分，但由另一条在对角线（k+1或k-1）上的最远到达的(D-1)-路径组成的一条在对角线k上的D-路径不一定是D-路径在对角线k上能够最远到达的。）

　　在对角线(k+1)和(k-1)上分别给定最远到达的(D-1)-路径的终点，$(x^{'},y^{'}),(x^{''},y^{"})$。引理2给出了一个计算D-路径在对角线k上最远到达的终点的程序。~~[即，取$(x^{'},y^{'}+1)$和$(x^{"}+1,y^{"})$中能够更远到达]~~ 此外，通过引理1，D-路径结束的端点所在的对角线只有 $D+1$条。这启示了计算D-路径在相应的$D+1$条对角线的终点，通过连续增长D的值直到最远到达路径在对角线$N-M$上到达端点(N,M)。

```
For D ← 0 to (M+N) Do
	For k ← −D to D in steps of 2 Do
		Find the endpoint of the furthest reaching D-path in diagonal k.
		If (N,M) is the endpoint Then
			The D-path is an optimal solution.
			Stop
```

　　当遇到最小的D使得最远到达的D-路径到达(N,M)，上面的程序就会停止。这肯定会在外层循环终止之前停止，因为D肯定是小于等于M+N的。这条路径肯定会有最小数量的非对角线边。因此这是一个LCS/SES问题的解决方案。

​		下图2展示了算法的细节，使用了很多简单的优化。一个数组V，元素$V[-D],V[-D+2],…,V[D-2],V[D]$是最远到达的D-路径的终点。通过引理1，这个集合中的元素与外层循环的下一次迭代要存储的(D+1)-路径的终点是不相交的。因此数组V可以同时保存D-路径的终点和从它们计算出来的(D+1)-路径的终点。此外，只需要保存x就可以记录在对角线k上的终点(x,y)，因为已知y是等于x-k的。因此，V是一个整数数组，其中V[k]是在对角线k上最远到达的终点的行索引(横坐标)。

![figure-2](https://github.com/MouJieQin/mydiff/wiki/figure.2.the-greedly-LCS_SES-algorithm.png)

​                                                                              **图2** LCS/SES的贪婪算法

​		作为一个搜索D-路径(D<=MAX)的实际问题的算法，当没有到达(N,M)的路径时，在14行，它会报告从A到B的任意编辑脚本肯定比MAX长。通过在上面的大纲上设置常量MAX为M+N，算法会保证找到LCS/SES的长度。图3展示了将该算法应用于图1中样例的搜索路径。请注意算法第1行虚设的终点，(0,-1)，用来寻找0-路径最远到达的端点。也请注意随着算法的推进，D-路径适当地延展了编辑图的左下边界。假设这个区域没有对角线，即可以正确处理这种边界情况。



![figure-3](https://github.com/MouJieQin/mydiff/wiki/figure.3.Furthest-reaching-paths.png)



​                                                                              **图3** 最远到达的路径

贪婪算法最多消耗O((M+N)D)的时间，行1和行14消耗O(1)时间。内层循环（行3）最多重复(D+1)(D+2)/2次，因为外层循环(行2)重复D+1次，内层循环的第k次迭代最多重复k次。除**while循环（行9）**外，内层循环中所有的行都只花费常数时间。因此行2-8和行10-13消耗$O(D^2)$时间。当扩展最远到达路径时，每条对角线边遍历一次，while循环迭代一次。但是最多只有O((M+N)D)条对角线边被遍历，因为所有的D-路径都在对角线-D和D之间，在这一区域内最多有$(2D+1)·min(N,M)$个点（该区域有$2D+1$条对角线，超过边界的虚拟点不会进入while循环，对角线上最多顶点的个数是行列数中较小的一个。）。因此算法总计需要O((M+N)D)时间。注意到只有行9，遍历蛇是限制步骤。算法的其余部分是$O(D^2)$时间的。此外，在实际情况下，阈值被设置为远小于M+N，算法花费绝不会超过O((M+N)MAX)的时间。

贪婪算法的搜索主要是跟踪最优的D-路径。但V中只保存了当前的最远到达集合的终点。因此，该算法只能在行12报告SES/LCS的长度。想要产生一个明确的路径方案，需要使用$O(D^2)$的空间存储在外层循环每次迭代后V的一份拷贝。设$V_d$为第d次迭代后V的拷贝。要列出从(0,0)到点$V_{d-1}[k+1]$的最优路径，取决于它是从$V_{d-1}[k+1]$跟随一个垂直边，再跟随一条最大蛇的末端，还是$V_{d-1}[k-1]$后跟随一条水平边，再跟随一条最大蛇的末端。具体而言，假设是$V_{d-1}[k-1]$，递归列出从(0,0)到该点的最优路径，然后列出对应的垂直边和到$V_d[k]$的最大蛇。当$d=0$时递归停止，此时列出从(0,0)到$(V_0[0],V_0[0])$的蛇。所以让$V_D[N-M]$作为初始化点的递归程序替代第12行，使用额外的$O(M+N)$时间和$O(D^2)$的空间，可以列出一条最优路径。在下一个章节中将会展示只需要$O(M+N)$空间的改进算法。

如第2节所述，LCS/SES问题可以看做是权重编辑图中一个单源最短路径的一个实例。这表明特化的Dijkstra算法[3]是一个有效算法。一个基础的练习显示了算法花费$O(ElgV)$时间，其中E是主题图中边的数量，V是顶点的数量。在编辑图中$E<3V$，因为每一个点的出度最多是3。此外，$lgV$来自于管理一个优先队列的开销。在这种情况下，优先队列将是属于$[0,M+N]$的整数，因为边的开销是0或1，并且到任意点的最长路径是M+N。在这些条件下，优先队列操作可以使用"桶(bucketing)"和链接表技术实现为常数时间。因此，在编辑图中，Dijkstra算法可以被特化对应于顶点数量的线性时间，即$(MN)$。最后的改进来源于注意到需要的是从源(0,0)到点(M,N)的最短路径。每迭代一个顶点，Dijkstra算法以增序确定了从原点到顶点的最小的距离。通过引理1，最多有$O((M+N)D)$的点比(M,N)到(0,0)的距离小，并且前面的改进减少每次迭代的开销到O(1)。因此算法一旦确定了到达(M,N)的最小距离就可以停止，这样做只花费O((M+N)D)的时间。

对于LCS/SES问题，已经给出了一个特化的Dijkstra算法，也给出了一个O(ND)时间的算法。生成的算法涉及一个相对复杂的离散优先级队列，该队列可能包含多达O(ND)项，即使在计算LCS/SES长度的情况下也是如此。虽然可以说进一步的改进引导了本文的简单算法，这种联系变得很薄弱，以至于本节中直接而简单的目的推导更可取的。讨论的目的是去揭示在最短路径，LCS/SES问题和它们的算法之间的密切联系。

## 4.精炼

基础算法可以在很多方面得到改进。首先，算法期待的性能是$O(M+N+D^2)$，比最坏情况预测的$O((M+N)D)$要好得多。虽然这里没有显示，但实验显示，平均值的方差很小，特别是当字符表的大小变大时。因此，要求$O((M+N)D)$时间的病态情况是是极为罕见的（例如，像快速排序的$O(N^2)$问题）。第二，算法可以改进到只使用线性空间其报告一个编辑脚本。其它唯一被证明有这种改进的是一个基础的O(MN)动态规划算法[7]。线性空间算法拥有重要的实用价值，因为许多问题可以合理的在O(D^2)时间解决，而不是用O(D^2)的空间。最后，使用一些以前开发出的技术[6,14]来加速遍历蛇可以得到$O( (M + N) lg(M + N) + D^2)$最坏时间的变体。由于构成变体的底层方法的复杂性，变体是不切实际的，但它再最坏情况下的渐进最优性具有理论价值。



